// cs/net/proto/db/field_path_builder.gpt.hh
#ifndef CS_NET_PROTO_DB_FIELD_PATH_BUILDER_GPT_HH
#define CS_NET_PROTO_DB_FIELD_PATH_BUILDER_GPT_HH

#include <string>
#include <type_traits>

namespace cs::net::proto::db {

template <typename T, typename FieldType>
std::string GetFieldPath(FieldType T::*member_ptr) {
  // Default implementation - should be specialized by
  // codegen For now, return empty string as fallback
  return "";
}

template <typename T>
struct FieldProxy {
  std::string path;

  FieldProxy() : path("") {}
  explicit FieldProxy(const std::string& p) : path(p) {}

  template <typename FieldType>
  FieldProxy<FieldType> operator>>(FieldType T::*ptr) {
    std::string field_path = GetFieldPath(ptr);
    std::string new_path;
    if (path.empty()) {
      new_path = field_path;
    } else {
      new_path = path + "." + field_path;
    }
    return FieldProxy<FieldType>{new_path};
  }

  const std::string& get_path() const { return path; }
};

template <typename T>
struct FieldPathBuilder {
  std::string path;

  FieldPathBuilder() : path("") {}
  explicit FieldPathBuilder(const std::string& p)
      : path(p) {}

  template <typename FieldType>
  FieldProxy<FieldType> operator>>(FieldType T::*ptr) {
    std::string field_path = GetFieldPath(ptr);
    std::string new_path;
    if (path.empty()) {
      new_path = field_path;
    } else {
      new_path = path + "." + field_path;
    }
    return FieldProxy<FieldType>{new_path};
  }

  const std::string& get_path() const { return path; }
};

// Note: FieldPathBuilder is typically used via
// codegen-generated instances like: `log >> request >>
// path` where `log` is a FieldPathBuilder<Log> instance
// generated by codegen.

template <typename T>
std::string GetFieldPathOrConvert(T&& arg) {
  if constexpr (std::is_member_pointer_v<std::decay_t<T>>) {
    return GetFieldPath(arg);
  } else if constexpr (std::is_convertible_v<
                           std::decay_t<T>, const char*>) {
    // Handle string literals for backward compatibility
    return std::string(arg);
  } else if constexpr (std::is_same_v<std::decay_t<T>,
                                      std::string>) {
    // Handle std::string directly
    return std::string(arg);
  } else {
    return std::string(arg.get_path());
  }
}

}  // namespace cs::net::proto::db

#endif  // CS_NET_PROTO_DB_FIELD_PATH_BUILDER_GPT_HH
